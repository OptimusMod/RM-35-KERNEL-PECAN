diff --git a/drivers/media/video/msm/isx005.c b/drivers/media/video/msm/isx005.c
index 027ebff..e9931af 100644
--- a/drivers/media/video/msm/isx005.c
+++ b/drivers/media/video/msm/isx005.c
@@ -24,13 +24,18 @@
 #include <linux/i2c.h>
 #include <linux/uaccess.h>
 #include <linux/miscdevice.h>
-#include <linux/slab.h>
 #include <media/msm_camera.h>
 #include <mach/gpio.h>
 #include <linux/kthread.h>
 
+//#define ISX005_TUN
+
+#if defined(ISX005_TUN)
+#include "isx005_tun.c"
+#else
 #include "isx005.h"
 #include "isx005_reg.h"
+#endif
 
 /*
 * AF Total steps parameters
@@ -54,6 +59,13 @@ static int cfg_wq_num;
 static int prev_af_mode;
 /* It is distinguish scene mode */
 static int prev_scene_mode;
+/* 2010-12-06 fixed run changing framerate mode repeatly */
+//static int prev_fps_mode;
+// 2010-12-31 reduce preview init time
+static bool skipFstUICmd;
+static bool chgUICmd;
+// 2011-03-21 Samsung camera sensor porting
+static int sensor_type;
 
 static struct i2c_client *isx005_client;
 
@@ -110,6 +122,7 @@ static int32_t isx005_i2c_write(unsigned short saddr,
 		buf[1] = (waddr & 0x00FF);
 		buf[2] = (wdata & 0xFF00) >> 8;
 		buf[3] = (wdata & 0x00FF);
+
 		rc = isx005_i2c_txdata(saddr, buf, 4);
 		break;
 
@@ -124,27 +137,6 @@ static int32_t isx005_i2c_write(unsigned short saddr,
 	return rc;
 }
 
-static int32_t isx005_i2c_write_table(
-	struct isx005_register_address_value_pair const *reg_conf_tbl,
-	int num_of_items_in_table)
-{
-	int i;
-	int32_t rc = -EIO;
-
-	for (i = 0; i < num_of_items_in_table; ++i) {
-		rc = isx005_i2c_write(isx005_client->addr,
-			reg_conf_tbl->register_address,
-			reg_conf_tbl->register_value,
-			reg_conf_tbl->register_length);
-		if (rc < 0)
-			break;
-
-		reg_conf_tbl++;
-	}
-
-	return rc;
-}
-
 static int isx005_i2c_rxdata(unsigned short saddr,
 	unsigned char *rxdata, int length)
 {
@@ -211,1115 +203,610 @@ static int32_t isx005_i2c_read(unsigned short   saddr,
 	return rc;
 }
 
-#if defined(CONFIG_MACH_MSM7X27_THUNDERG) || \
-	defined(CONFIG_MACH_MSM7X27_THUNDERA)
-static int isx005_reg_init(void)
+static int32_t isx005_i2c_write_table(
+	struct isx005_register_address_value_pair const *reg_conf_tbl,
+	int num_of_items_in_table)
 {
-	int rc = 0;
 	int i;
+	int32_t rc = -EIO;
+	unsigned short temp;
 
-	/* Configure sensor for Initial setting (PLL, Clock, etc) */
-	for (i = 0; i < isx005_regs.init_reg_settings_size; ++i) {
-		rc = isx005_i2c_write(isx005_client->addr,
-			isx005_regs.init_reg_settings[i].register_address,
-			isx005_regs.init_reg_settings[i].register_value,
-			isx005_regs.init_reg_settings[i].register_length);
+	for (i = 0; i < num_of_items_in_table; ++i) {
+	 if (reg_conf_tbl->register_address == 0xdddd) {  // sensor register refresh polling
+	  do {
+ 	  isx005_i2c_write(isx005_client->addr, 0x098E, 0x8400, WORD_LEN);
+ 	  isx005_i2c_read(isx005_client->addr, 0x0990, &temp, WORD_LEN);
+
+ 	 } while( temp & 0x0006 );
+  } else if ( reg_conf_tbl->register_address == 0xeeee ) {  // 2010-11-24 add delay logic
+	   printk(KERN_ERR "delay time %d\n", reg_conf_tbl->register_value);
+	   mdelay(reg_conf_tbl->register_value);
+	 } else {
+ 		rc = isx005_i2c_write(isx005_client->addr,
+ 			reg_conf_tbl->register_address,
+ 			reg_conf_tbl->register_value,
+ 			reg_conf_tbl->register_length);
+ 		if (rc < 0)
+ 			break;
+ 	}
 
-		if (rc < 0)
-			return rc;
+		reg_conf_tbl++;
 	}
 
 	return rc;
 }
-#else
-static int isx005_reg_init(void)
-{
-	int rc = 0;
-	int i;
 
-	if (pclk_rate == 27) {
-		/* Configure sensor for Initial setting (PLL, Clock, etc) */
-		for (i = 0; i < isx005_regs.init_reg_settings_size; ++i) {
-			rc = isx005_i2c_write(isx005_client->addr,
-				isx005_regs.init_reg_settings[i].register_address,
-				isx005_regs.init_reg_settings[i].register_value,
-				isx005_regs.init_reg_settings[i].register_length);
+// 2011-03-21 Samsung camera sensor porting
+void isx005_register2_setting() {
+	isx005_regs.init_reg_settings = init_reg_settings_array2;
+	isx005_regs.init_reg_settings_size = ARRAY_SIZE(init_reg_settings_array2);
 
-			if (rc < 0)
-				return rc;
-		}
-	} else if (pclk_rate == 32) {
-		/* Configure sensor for Initial setting (PLL, Clock, etc) */
-		for (i = 0; i < isx005_regs.init_reg32_settings_size; ++i) {
-			rc = isx005_i2c_write(isx005_client->addr,
-				isx005_regs.init_reg32_settings[i].register_address,
-				isx005_regs.init_reg32_settings[i].register_value,
-				isx005_regs.init_reg32_settings[i].register_length);
+	isx005_regs.tuning_reg_settings = tuning_reg_settings_array2;
+	isx005_regs.tuning_reg_settings_size = ARRAY_SIZE(tuning_reg_settings_array2);
 
-			if (rc < 0)
-				return rc;
-		}
-	} else {
-		printk(KERN_ERR "invalid pclk rate!\n");
-		return -EINVAL;
-	}
+	isx005_regs.auto_framerate_reg_settings = auto_framerate_mode_reg_settings_array2;
+	isx005_regs.auto_framerate_reg_settings_size = ARRAY_SIZE(auto_framerate_mode_reg_settings_array2);
 
-	return rc;
-}
-#endif
+	isx005_regs.fixed_framerate_reg_settings = fixed_framerate_mode_reg_settings_array2;
+	isx005_regs.fixed_framerate_reg_settings_size = ARRAY_SIZE(fixed_framerate_mode_reg_settings_array2);
 
-static int dequeue_sensor_config(int cfgtype, int mode);
+	isx005_regs.prev_reg_settings = preview_mode_reg_settings_array2;
+	isx005_regs.prev_reg_settings_size = ARRAY_SIZE(preview_mode_reg_settings_array2);
 
-static void dequeue_cfg_wq(struct config_work_queue *cfg_wq)
-{
-	int rc;
-	int i;
-
-	for (i = 0; i < cfg_wq_num; ++i) {
-		rc = dequeue_sensor_config(cfg_wq[i].cfgtype, cfg_wq[i].mode);
-		if (rc < 0) {
-			printk(KERN_ERR "[ERROR]%s: dequeue sensor config error!\n",
-				__func__);
-			break;
-		}
-	}
+	isx005_regs.snap_reg_settings = snapshot_mode_reg_settings_array2;
+	isx005_regs.snap_reg_settings_size = ARRAY_SIZE(snapshot_mode_reg_settings_array2);
 
-	cfg_wq_num = 0;
-}
+	isx005_regs.effect_off_reg_settings = effect_mode_off_reg_settings_array2;
+	isx005_regs.effect_off_reg_settings_size = ARRAY_SIZE(effect_mode_off_reg_settings_array2);
 
-static void enqueue_cfg_wq(int cfgtype, int mode)
-{
-	if (!cfg_wq) {
-		cfg_wq_num = 0;
-		return;
-	}
+	isx005_regs.effect_mono_reg_settings = effect_mode_mono_reg_settings_array2;
+	isx005_regs.effect_mono_reg_settings_size = ARRAY_SIZE(effect_mode_mono_reg_settings_array2);
 
-	if (cfg_wq_num == CFG_WQ_SIZE)
-		return;
+	isx005_regs.effect_negative_reg_settings = effect_mode_negative_reg_settings_array2;
+	isx005_regs.effect_negative_reg_settings_size = ARRAY_SIZE(effect_mode_negative_reg_settings_array2);
 
-	cfg_wq[cfg_wq_num].cfgtype = cfgtype;
-	cfg_wq[cfg_wq_num].mode = mode;
+	isx005_regs.effect_solarize_reg_settings = effect_mode_solarize_reg_settings_array2;
+	isx005_regs.effect_solarize_reg_settings_size = ARRAY_SIZE(effect_mode_solarize_reg_settings_array2);
 
-	++cfg_wq_num;
-}
+	isx005_regs.effect_sepia_reg_settings = effect_mode_sepia_reg_settings_array2;
+	isx005_regs.effect_sepia_reg_settings_size = ARRAY_SIZE(effect_mode_sepia_reg_settings_array2);
 
-int isx005_reg_tuning(void *data)
-{
-	int rc = 0;
-	int i;
+	isx005_regs.effect_aqua_reg_settings = effect_mode_aqua_reg_settings_array2;
+	isx005_regs.effect_aqua_reg_settings_size = ARRAY_SIZE(effect_mode_aqua_reg_settings_array2);
 
-	mutex_lock(&isx005_tuning_mutex);
-	cfg_wq = kmalloc(sizeof(struct config_work_queue) * CFG_WQ_SIZE,
-		GFP_KERNEL);
-	cfg_wq_num = 0;
-	tuning_thread_run = 1;
-	mutex_unlock(&isx005_tuning_mutex);
+	isx005_regs.wb_auto_reg_settings = wb_mode_auto_reg_settings_array2;
+	isx005_regs.wb_auto_reg_settings_size = ARRAY_SIZE(wb_mode_auto_reg_settings_array2);
 
-	/* Configure sensor for various tuning */
-	for (i = 0; i < isx005_regs.tuning_reg_settings_size; ++i) {
-		rc = isx005_i2c_write(isx005_client->addr,
-			isx005_regs.tuning_reg_settings[i].register_address,
-			isx005_regs.tuning_reg_settings[i].register_value,
-			isx005_regs.tuning_reg_settings[i].register_length);
+	isx005_regs.wb_incandescent_reg_settings = wb_mode_incandescent_reg_settings_array2;
+	isx005_regs.wb_incandescent_reg_settings_size = ARRAY_SIZE(wb_mode_incandescent_reg_settings_array2);
 
-		if (rc < 0)
-			break;
-	}
+	isx005_regs.wb_fluorescent_reg_settings = wb_mode_fluorescent_reg_settings_array2;
+	isx005_regs.wb_fluorescent_reg_settings_size = ARRAY_SIZE(wb_mode_fluorescent_reg_settings_array2);
 
-	mutex_lock(&isx005_tuning_mutex);
-	dequeue_cfg_wq(cfg_wq);
-	kfree(cfg_wq);
-	cfg_wq = 0;
-	tuning_thread_run = 0;
-	mutex_unlock(&isx005_tuning_mutex);
+	isx005_regs.wb_daylight_reg_settings = wb_mode_daylight_reg_settings_array2;
+	isx005_regs.wb_daylight_reg_settings_size = ARRAY_SIZE(wb_mode_daylight_reg_settings_array2);
 
-	return rc;
-}
+	isx005_regs.wb_cloudy_reg_settings = wb_mode_cloudy_reg_settings_array2;
+	isx005_regs.wb_cloudy_reg_settings_size = ARRAY_SIZE(wb_mode_cloudy_reg_settings_array2);
 
-static int isx005_reg_preview(void)
-{
-	int rc = 0;
-	int i;
+	isx005_regs.iso_auto_reg_settings = iso_mode_auto_reg_settings_array2;
+	isx005_regs.iso_auto_reg_settings_size = ARRAY_SIZE(iso_mode_auto_reg_settings_array2);
 
-	/* Configure sensor for Preview mode */
-	for (i = 0; i < isx005_regs.prev_reg_settings_size; ++i) {
-		rc = isx005_i2c_write(isx005_client->addr,
-		  isx005_regs.prev_reg_settings[i].register_address,
-		  isx005_regs.prev_reg_settings[i].register_value,
-		  isx005_regs.prev_reg_settings[i].register_length);
+	isx005_regs.iso_100_reg_settings = iso_mode_100_reg_settings_array2;
+	isx005_regs.iso_100_reg_settings_size = ARRAY_SIZE(iso_mode_100_reg_settings_array2);
 
-		if (rc < 0)
-			return rc;
-	}
+	isx005_regs.iso_200_reg_settings = iso_mode_200_reg_settings_array2;
+	isx005_regs.iso_200_reg_settings_size = ARRAY_SIZE(iso_mode_200_reg_settings_array2);
 
-	/* Checking the mode change status
-	 * BUG FIX : msm is changed preview mode but sensor is not change
-	 * preview mode.
-	 *so there is case that vfe get capture image on preview mode
-	 * eunyoung.shin@lge.com 2010.07.13 */
-	for (i = 0; i < 300; i++) {
-		unsigned short cm_changed_status = 0;
-		rc = isx005_i2c_read(isx005_client->addr, 0x00F8,
-			&cm_changed_status,	BYTE_LEN);
-
-		if (cm_changed_status & 0x0002) {
-			CDBG("[%s]:Sensor Preview Mode check : %d-> success \n",
-				__func__, cm_changed_status);
-			break;
-		} else
-			msleep(10);
-	}
+	isx005_regs.iso_400_reg_settings = iso_mode_400_reg_settings_array2;
+	isx005_regs.iso_400_reg_settings_size = ARRAY_SIZE(iso_mode_400_reg_settings_array2);
 
-	return rc;
+	isx005_regs.brightness_reg_settings = brightness_reg_settings_array2;
+	isx005_regs.brightness_reg_settings_size = ARRAY_SIZE(brightness_reg_settings_array2);
 }
 
-static int isx005_reg_snapshot(void)
+/* pll register setting */
+static int isx005_reg_init(void)
 {
 	int rc = 0;
 	int i;
-    unsigned short cm_changed_status = 0;
+	unsigned short temp;
 
-	/* Configure sensor for Snapshot mode */
-	for (i = 0; i < isx005_regs.snap_reg_settings_size; ++i) {
-		rc = isx005_i2c_write(isx005_client->addr,
-			isx005_regs.snap_reg_settings[i].register_address,
-			isx005_regs.snap_reg_settings[i].register_value,
-			isx005_regs.snap_reg_settings[i].register_length);
+	/* Configure sensor for Initial setting (PLL, Clock, etc) */
+	for (i = 0; i < isx005_regs.init_reg_settings_size; ++i) {
+	 // 2010-12-25 add pll delay=10ms
+	 if ( isx005_regs.init_reg_settings[i].register_address == 0xeeee) {
+	  printk(KERN_ERR "pll delay %d\n", isx005_regs.init_reg_settings[i].register_value);
+	  mdelay(isx005_regs.init_reg_settings[i].register_value);
+	 } else if ( isx005_regs.init_reg_settings[i].register_address == 0xdddd ) {
+    do {
+     isx005_i2c_read(isx005_client->addr, 0x0018, &temp, WORD_LEN);
+     printk(KERN_ERR "pll polling 0x%x\n", temp);
+    } while( temp & 0x4000 );
+	 } else {
+  		rc = isx005_i2c_write(isx005_client->addr,
+  			isx005_regs.init_reg_settings[i].register_address,
+  			isx005_regs.init_reg_settings[i].register_value,
+  			isx005_regs.init_reg_settings[i].register_length);
+  }
 
 		if (rc < 0)
 			return rc;
 	}
 
-	/* Checking the mode change status */
-	/* eunyoung.shin@lge.com 2010.07.13 */
-	for (i = 0; i < 300; i++) {
-		CDBG("[%s]:Sensor Snapshot Mode Start\n", __func__);
-		cm_changed_status = 0;
-		rc = isx005_i2c_read(isx005_client->addr, 0x00F8,
-			&cm_changed_status,	BYTE_LEN);
-
-		if (cm_changed_status & 0x0002) {
-			CDBG("[%s]:Sensor Snapshot Mode check : %d-> success \n",
-				__func__, cm_changed_status);
-			break;
-		} else
-			msleep(10);
-
-		CDBG("[%s]:Sensor Snapshot Mode checking : %d \n", __func__,
-			cm_changed_status);
-	}
-
-	 return rc;
-}
-
-static int isx005_set_sensor_mode(int mode)
-{
-	int rc = 0;
-	int retry = 0;
-
-	switch (mode) {
-	case SENSOR_PREVIEW_MODE:
-		for (retry = 0; retry < 3; ++retry) {
-			rc = isx005_reg_preview();
-			if (rc < 0)
-				printk(KERN_ERR "[ERROR]%s:Sensor Preview Mode Fail\n",
-					__func__);
-			else
-				break;
-		}
-		break;
-
-	case SENSOR_SNAPSHOT_MODE:
-	case SENSOR_RAW_SNAPSHOT_MODE:	/* Do not support */
-		for (retry = 0; retry < 3; ++retry) {
-			rc = isx005_reg_snapshot();
-			if (rc < 0)
-				printk(KERN_ERR "[ERROR]%s:Sensor Snapshot Mode Fail\n",
-					__func__);
-			else
-				break;
-		}
-		break;
-
-	default:
-		return -EINVAL;
-	}
-
-	CDBG("Sensor Mode : %d, rc = %d\n", mode, rc);
-
-	return rc;
-}
-
-static int isx005_cancel_focus(int mode)
-{
-	int rc;
-	int lense_po_back = 0;
-
-	switch (mode) {
-	case 0:
-		lense_po_back = 0x3200;
-		break;
-
-	case 1:
-		lense_po_back = 0x0403;
-		break;
-	}
-
-	rc = isx005_i2c_write(isx005_client->addr,
-			0x002E, 0x02, BYTE_LEN);
-	if (rc < 0)
-		return rc;
-
-	rc = isx005_i2c_write(isx005_client->addr,
-			0x4852, lense_po_back, WORD_LEN);
-	if (rc < 0)
-		return rc;
-
-	rc = isx005_i2c_write(isx005_client->addr,
-			0x0012, 0x01, BYTE_LEN);
-	if (rc < 0)
-		return rc;
-
-	rc = isx005_i2c_write(isx005_client->addr,
-			0x4850, 0x01, BYTE_LEN);
-	if (rc < 0)
-		return rc;
-
-	rc = isx005_i2c_write(isx005_client->addr,
-			0x00FC, 0x1F, BYTE_LEN);
-	if (rc < 0)
-		return rc;
-
-	return rc;
-}
-
-static int isx005_check_af_lock(void)
-{
-	int rc;
-	int i;
-	unsigned short af_lock;
-
-	for (i = 0; i < 10; ++i) {
-		/*INT state read -*/
-		rc = isx005_i2c_read(isx005_client->addr,
-			0x00F8, &af_lock, BYTE_LEN);
-
-		if (rc < 0) {
-			CDBG("isx005: reading af_lock fail\n");
-			return rc;
-		}
-
-		/* af interruption lock state read compelete */
-		if ((af_lock & 0x10) == 0x10)
-			break;
-
-		msleep(10);
-	}
-
-	/* INT clear */
-	rc = isx005_i2c_write(isx005_client->addr,
-		0x00FC, 0x10, BYTE_LEN);
-	if (rc < 0)
-		return rc;
-
-	for (i = 0; i < 10; ++i) {
-		/*INT state read to confirm INT release state*/
-		rc = isx005_i2c_read(isx005_client->addr,
-				0x00F8, &af_lock, BYTE_LEN);
-
-		if (rc < 0) {
-			CDBG("isx005: reading af_lock fail\n");
-			return rc;
-		}
-
-		if ((af_lock & 0x10) == 0x00) {
-			CDBG("af_lock is released\n");
-			break;
-		}
-		msleep(10);
-	}
-
-	return rc;
-}
-
-static int isx005_check_focus(int *lock)
-{
-	int rc;
-	unsigned short af_status;
-	unsigned short af_result;
-
-	CDBG("isx005_check_focus\n");
-
-	/*af status check  0:load, 1: init,  8: af_lock */
-	rc = isx005_i2c_read(isx005_client->addr,
-		0x6D76, &af_status, BYTE_LEN);
-
-	if (af_status != 0x8)
-		return -ETIME;
-
-	isx005_check_af_lock();
-
-	/* af result read  success / fail*/
-	rc = isx005_i2c_read(isx005_client->addr, 0x6D77, &af_result, BYTE_LEN);
-	if (rc < 0) {
-		printk(KERN_ERR "[isx005.c]%s: fail in reading af_result\n",
-			__func__);
-		return rc;
-	}
-
-	/* single autofocus off */
-	rc = isx005_i2c_write(isx005_client->addr, 0x002E, 0x03, BYTE_LEN);
-	if (rc < 0)
-		return rc;
-
-	/* single autofocus refresh*/
-	rc = isx005_i2c_write(isx005_client->addr, 0x0012, 0x01, BYTE_LEN);
-	if (rc < 0)
-		return rc;
-
-	if (af_result == 1) {
-		*lock = CFG_AF_LOCKED;		/* success */
-		return rc;
-	} else {
-		*lock = CFG_AF_UNLOCKED;	/* fail */
-		return rc;
-	}
-
-	return -ETIME;
-}
-
-static int isx005_set_af_start(int mode)
-{
-	int rc = 0;
-
-	if (prev_af_mode == mode) {
-		rc = isx005_i2c_write_table(
-			isx005_regs.af_start_reg_settings,
-			isx005_regs.af_start_reg_settings_size);
-	} else {
-		switch (mode) {
-		case FOCUS_NORMAL:
-			rc = isx005_i2c_write_table(
-				isx005_regs.af_normal_reg_settings,
-				isx005_regs.af_normal_reg_settings_size);
-			break;
-
-		case FOCUS_MACRO:
-			rc = isx005_i2c_write_table(
-				isx005_regs.af_macro_reg_settings,
-				isx005_regs.af_macro_reg_settings_size);
-			break;
-
-		case FOCUS_AUTO:
-			rc = isx005_i2c_write_table(
-				isx005_regs.af_normal_reg_settings,
-				isx005_regs.af_normal_reg_settings_size);
-			break;
-
-		case FOCUS_MANUAL:
-			rc = isx005_i2c_write_table(
-				isx005_regs.af_manual_reg_settings,
-				isx005_regs.af_manual_reg_settings_size);
-			break;
-
-		default:
-			printk(KERN_ERR "[ERROR]%s: invalid af mode\n", __func__);
-			break;
-		}
-		/*af start*/
-		rc = isx005_i2c_write_table(isx005_regs.af_start_reg_settings,
-			isx005_regs.af_start_reg_settings_size);
-	}
-
-	prev_af_mode = mode;
-
-	return rc;
-}
-
-static int isx005_move_focus(int32_t steps)
-{
-	int32_t rc;
-	unsigned short cm_changed_sts, cm_changed_clr, af_pos, manual_pos;
-	int i;
-
-	rc = isx005_i2c_write_table(isx005_regs.af_manual_reg_settings,
-			isx005_regs.af_manual_reg_settings_size);
-
-	prev_af_mode = FOCUS_MANUAL;
-
-	if (rc < 0) {
-		printk(KERN_ERR "[ERROR]%s:fail in writing for move focus\n",
-			__func__);
-		return rc;
-	}
-
-	/* check cm_changed_sts */
-	for (i = 0; i < 24; ++i) {
-		rc = isx005_i2c_read(isx005_client->addr,
-				0x00F8, &cm_changed_sts, BYTE_LEN);
-		if (rc < 0) {
-			printk(KERN_ERR "[ERROR]%s; fail in reading cm_changed_sts\n",
-				__func__);
-			return rc;
-		}
-
-		if ((cm_changed_sts & 0x02) == 0x02)
-			break;
-
-		msleep(10);
-	}
-
-	/* clear the interrupt register */
-	rc = isx005_i2c_write(isx005_client->addr, 0x00FC, 0x02, BYTE_LEN);
-	if (rc < 0)
-		return rc;
-
-	/* check cm_changed_clr */
-	for (i = 0; i < 24; ++i) {
-		rc = isx005_i2c_read(isx005_client->addr,
-			0x00FC, &cm_changed_clr, BYTE_LEN);
-		if (rc < 0) {
-			printk(KERN_ERR "[ERROR]%s:fail in reading cm_changed_clr\n",
-				__func__);
-			return rc;
-		}
-
-		if ((cm_changed_clr & 0x00) == 0x00)
-			break;
-
-		msleep(10);
-	}
-
-	if (steps <= 10)
-		manual_pos = cpu_to_be16(50 + (50 * steps));
-	else
-		manual_pos = 50;
-
-	rc = isx005_i2c_write(isx005_client->addr, 0x4852, manual_pos,
-		WORD_LEN);
-	if (rc < 0)
-		return rc;
-
-	rc = isx005_i2c_write(isx005_client->addr, 0x4850, 0x01, BYTE_LEN);
-	if (rc < 0)
-		return rc;
-
-	rc = isx005_i2c_write(isx005_client->addr, 0x0015, 0x01, BYTE_LEN);
-	if (rc < 0)
-		return rc;
-
-	isx005_check_af_lock();
-
-	/* check lens position */
-	for (i = 0; i < 24; ++i) {
-		rc = isx005_i2c_read(isx005_client->addr, 0x6D7A, &af_pos, WORD_LEN);
-		if (rc < 0) {
-			printk(KERN_ERR "[ERROR]%s:fail in reading af_lenspos\n",
-				__func__);
-			return rc;
-		}
-
-		if (af_pos == manual_pos)
-			break;
-
-		msleep(10);
-	}
-
-	return rc;
-}
-
-static int isx005_set_default_focus(void)
-{
-	int rc;
-
-	rc = isx005_cancel_focus(prev_af_mode);
-	if (rc < 0) {
-		printk(KERN_ERR "[ERROR]%s:fail in cancel_focus\n", __func__);
-		return rc;
-	}
-
-	rc = isx005_i2c_write_table(isx005_regs.af_normal_reg_settings,
-		isx005_regs.af_normal_reg_settings_size);
-
-	prev_af_mode = FOCUS_AUTO;
-
-	if (rc < 0) {
-		printk(KERN_ERR "[ERROR]%s:fail in writing for focus\n", __func__);
-		return rc;
-	}
-
-	msleep(60);
-
-	isx005_check_focus(&rc);
-
 	return rc;
 }
 
-
-static int isx005_set_effect(int effect)
+static void enqueue_cfg_wq(int cfgtype, int mode)
 {
-	int rc = 0;
-
-	switch (effect) {
-	case CAMERA_EFFECT_OFF:
-		rc = isx005_i2c_write(isx005_client->addr, 0x005F, 0x00,
-			BYTE_LEN);
-		if (rc < 0)
-			return rc;
-
-		rc = isx005_i2c_write(isx005_client->addr, 0x038A, 0x6911,
-			WORD_LEN);
-		if (rc < 0)
-			return rc;
-
-		break;
-
-	case CAMERA_EFFECT_MONO:
-		rc = isx005_i2c_write(isx005_client->addr, 0x005F, 0x04,
-			BYTE_LEN);
-		if (rc < 0)
-			return rc;
-
-		rc = isx005_i2c_write(isx005_client->addr, 0x038A, 0x6911,
-			WORD_LEN);
-		if (rc < 0)
-			return rc;
-
-		break;
-
-	case CAMERA_EFFECT_NEGATIVE:
-		rc = isx005_i2c_write(isx005_client->addr, 0x005F, 0x02,
-			BYTE_LEN);
-		if (rc < 0)
-			return rc;
-
-		rc = isx005_i2c_write(isx005_client->addr, 0x038A, 0x6911,
-			WORD_LEN);
-		if (rc < 0)
-			return rc;
-
-		break;
-
-	case CAMERA_EFFECT_SOLARIZE:
-		rc = isx005_i2c_write(isx005_client->addr, 0x005F, 0x01,
-			BYTE_LEN);
-		if (rc < 0)
-			return rc;
-
-		rc = isx005_i2c_write(isx005_client->addr, 0x038A, 0x6911,
-			WORD_LEN);
-		if (rc < 0)
-			return rc;
-
-		break;
-
-	case CAMERA_EFFECT_SEPIA:
-		rc = isx005_i2c_write(isx005_client->addr, 0x005F, 0x03,
-			BYTE_LEN);
-		if (rc < 0)
-			return rc;
-
-		rc = isx005_i2c_write(isx005_client->addr, 0x038A, 0x6911,
-			WORD_LEN);
-		if (rc < 0)
-			return rc;
-
-		break;
-
-	/* This effect is not supported in ISX005 */
-	case CAMERA_EFFECT_POSTERIZE:
-		rc = isx005_i2c_write(isx005_client->addr, 0x005F, 0x00,
-			BYTE_LEN);
-		if (rc < 0)
-			return rc;
-
-		rc = isx005_i2c_write(isx005_client->addr, 0x038A, 0x6911,
-			WORD_LEN);
-		if (rc < 0)
-			return rc;
-
-		break;
-
-	/* This effect is not supported in ISX005 */
-	case CAMERA_EFFECT_AQUA:
-		rc = isx005_i2c_write(isx005_client->addr, 0x005F, 0x00,
-			BYTE_LEN);
-		if (rc < 0)
-			return rc;
-
-		rc = isx005_i2c_write(isx005_client->addr, 0x038A, 0x6911,
-			WORD_LEN);
-		if (rc < 0)
-			return rc;
-
-		break;
-
-	case CAMERA_EFFECT_NEGATIVE_SEPIA:
-		rc = isx005_i2c_write(isx005_client->addr, 0x005F, 0x02,
-			BYTE_LEN);
-		if (rc < 0)
-			return rc;
-
-		rc = isx005_i2c_write(isx005_client->addr, 0x038A, 0x6D11,
-			WORD_LEN);
-		if (rc < 0)
-			return rc;
-
-		break;
-
-	case CAMERA_EFFECT_BLUE:
-		rc = isx005_i2c_write(isx005_client->addr, 0x005F, 0x03,
-			BYTE_LEN);
-		if (rc < 0)
-			return rc;
-
-		rc = isx005_i2c_write(isx005_client->addr, 0x038A, 0x6D11,
-			WORD_LEN);
-		if (rc < 0)
-			return rc;
-		break;
-
-	case CAMERA_EFFECT_PASTEL:
-		rc = isx005_i2c_write(isx005_client->addr, 0x005F, 0x05,
-			BYTE_LEN);
-		if (rc < 0)
-			return rc;
-
-		rc = isx005_i2c_write(isx005_client->addr, 0x038A, 0x6911,
-			WORD_LEN);
-		if (rc < 0)
-			return rc;
-		break;
-
-	default:
-		return -EINVAL;
+	if (!cfg_wq) {
+		cfg_wq_num = 0;
+		return;
 	}
 
-	CDBG("Effect : %d, rc = %d\n", effect, rc);
-
-	return rc;
-}
-
-static int isx005_set_wb(int mode)
-{
-	int rc;
-
-	switch (mode) {
-	case CAMERA_WB_AUTO:
-		rc = isx005_i2c_write(isx005_client->addr, 0x4453, 0x7B,
-			BYTE_LEN);
-		if (rc < 0)
-			return rc;
-
-		rc = isx005_i2c_write(isx005_client->addr, 0x0102, 0x20,
-			BYTE_LEN);
-		if (rc < 0)
-			return rc;
-
-		break;
-
-	case CAMERA_WB_CUSTOM:	/* Do not support */
-		rc = isx005_i2c_write(isx005_client->addr, 0x4453, 0x7B,
-			BYTE_LEN);
-		if (rc < 0)
-			return rc;
-
-		rc = isx005_i2c_write(isx005_client->addr, 0x0102, 0x20,
-			BYTE_LEN);
-		if (rc < 0)
-			return rc;
-
-		break;
-
-	case CAMERA_WB_INCANDESCENT:
-		rc = isx005_i2c_write(isx005_client->addr, 0x4453, 0x3B,
-			BYTE_LEN);
-		if (rc < 0)
-			return rc;
-
-		rc = isx005_i2c_write(isx005_client->addr, 0x0102, 0x08,
-			BYTE_LEN);
-		if (rc < 0)
-			return rc;
-
-		break;
-
-	case CAMERA_WB_FLUORESCENT:
-		rc = isx005_i2c_write(isx005_client->addr, 0x4453, 0x3B,
-			BYTE_LEN);
-		if (rc < 0)
-			return rc;
-
-		rc = isx005_i2c_write(isx005_client->addr, 0x0102, 0x07,
-			BYTE_LEN);
-		if (rc < 0)
-			return rc;
-
-		break;
-
-	case CAMERA_WB_DAYLIGHT:
-		rc = isx005_i2c_write(isx005_client->addr, 0x4453, 0x3B,
-			BYTE_LEN);
-		if (rc < 0)
-			return rc;
-
-		rc = isx005_i2c_write(isx005_client->addr, 0x0102, 0x04,
-			BYTE_LEN);
-		if (rc < 0)
-			return rc;
-
-		break;
+	if (cfg_wq_num == CFG_WQ_SIZE)
+		return;
 
-	case CAMERA_WB_CLOUDY_DAYLIGHT:
-		rc = isx005_i2c_write(isx005_client->addr, 0x4453, 0x3B,
-			BYTE_LEN);
-		if (rc < 0)
-			return rc;
+	cfg_wq[cfg_wq_num].cfgtype = cfgtype;
+	cfg_wq[cfg_wq_num].mode = mode;
 
-		rc = isx005_i2c_write(isx005_client->addr, 0x0102, 0x06,
-			BYTE_LEN);
-		if (rc < 0)
-			return rc;
+	++cfg_wq_num;
+}
 
-		break;
+/* init register setting (Aptina) */
+int isx005_reg_tuning(void)
+{
+	int rc = 0;
+	int i;
+	unsigned short temp;
 
-	case CAMERA_WB_TWILIGHT:	/* Do not support */
-		rc = isx005_i2c_write(isx005_client->addr, 0x4453, 0x7B,
-			BYTE_LEN);
-		if (rc < 0)
-			return rc;
+ printk(KERN_ERR "Aptina init_code\n");
 
-		rc = isx005_i2c_write(isx005_client->addr, 0x0102, 0x20,
-			BYTE_LEN);
-		if (rc < 0)
-			return rc;
+	for (i = 0; i < isx005_regs.tuning_reg_settings_size; ++i) {
+	 if ( isx005_regs.tuning_reg_settings[i].register_address == 0xdddd ) {
+	  do {
+ 	  isx005_i2c_write(isx005_client->addr, 0x098E, 0x8400, WORD_LEN);
+ 	  isx005_i2c_read(isx005_client->addr, 0x0990, &temp, WORD_LEN);
+ 	 } while( temp & 0x0006 );
+	 } else if ( isx005_regs.tuning_reg_settings[i].register_address == 0xddd1 ) {
+	  do {
+ 	  isx005_i2c_write(isx005_client->addr, 0x098E, 0x8400, WORD_LEN);
+ 	  isx005_i2c_read(isx005_client->addr, 0x0990, &temp, WORD_LEN);
+    printk(KERN_ERR "init extra polling %d\n", temp);
+ 	 } while( temp & 0x0005 );
+	 } else if ( isx005_regs.tuning_reg_settings[i].register_address == 0xeeee ) { // 20101103 used by sensor tuning
+	   printk(KERN_ERR "delay time %d\n", isx005_regs.tuning_reg_settings[i].register_value);
+	   mdelay(isx005_regs.tuning_reg_settings[i].register_value);
+	 } else if ( isx005_regs.tuning_reg_settings[i].register_address == 0xfff1 ) { // 20101111 check sensor patch ID
+	  do {
+ 	  isx005_i2c_write(isx005_client->addr, 0x098E, 0x800C, WORD_LEN);
+ 	  isx005_i2c_read(isx005_client->addr, 0x0990, &temp, WORD_LEN);
+ 	  printk(KERN_ERR "patch id %d\n", isx005_regs.tuning_reg_settings[i].register_value);
+ 	 } while( temp != isx005_regs.tuning_reg_settings[i].register_value );
+	 } else if ( isx005_regs.tuning_reg_settings[i].register_address == 0xfff2 ) { // 20101111 check sensor patch PASS
+	  do {
+ 	  isx005_i2c_write(isx005_client->addr, 0x098E, 0x800D, WORD_LEN);
+ 	  isx005_i2c_read(isx005_client->addr, 0x0990, &temp, WORD_LEN);
+ 	  printk(KERN_ERR "patch pass %d\n", isx005_regs.tuning_reg_settings[i].register_value);
+ 	 } while( temp != isx005_regs.tuning_reg_settings[i].register_value );
+	 } else {
+   	rc = isx005_i2c_write(isx005_client->addr,
+   		isx005_regs.tuning_reg_settings[i].register_address,
+   		isx005_regs.tuning_reg_settings[i].register_value,
+   		isx005_regs.tuning_reg_settings[i].register_length);
+  }
+ 	if (rc < 0)
+ 		break;
+	}
 
-		break;
+	return rc;
+}
 
-	case CAMERA_WB_SHADE:		/* Do not support */
-		rc = isx005_i2c_write(isx005_client->addr, 0x4453, 0x7B,
-			BYTE_LEN);
-		if (rc < 0)
-			return rc;
+/* init register setting (Samsung)*/
+int isx005_reg_tuning2(void)
+{
+	int rc = 0;
+	int i;
+	unsigned char buf[1500];
+	int bufIndex = 2;
 
-		rc = isx005_i2c_write(isx005_client->addr, 0x0102, 0x20,
-			BYTE_LEN);
-		if (rc < 0)
-			return rc;
+ printk(KERN_ERR "Samsung init_code\n");
 
-		break;
+ // for burst mode
+ buf[0] = 0x0F;
+ buf[1] = 0x12;
 
-	default:
-		return -EINVAL;
+	for (i = 0; i < isx005_regs.tuning_reg_settings_size; ++i) {
+  // burst mode
+	 if ( isx005_regs.tuning_reg_settings[i].register_address == 0x0F12 ) {
+	  buf[bufIndex] = (isx005_regs.tuning_reg_settings[i].register_value & 0xFF00) >> 8;
+	  bufIndex++;
+	  buf[bufIndex] = (isx005_regs.tuning_reg_settings[i].register_value & 0x00FF);
+	  bufIndex++;
+	 } else {
+	   if ( bufIndex > 2 ) {
+       rc = isx005_i2c_txdata(isx005_client->addr, buf, bufIndex+1);
+	      bufIndex = 2;
+	   }
+   	rc = isx005_i2c_write(isx005_client->addr,
+   		isx005_regs.tuning_reg_settings[i].register_address,
+   		isx005_regs.tuning_reg_settings[i].register_value,
+   		isx005_regs.tuning_reg_settings[i].register_length);
+  }
+
+ 	if (rc < 0)
+ 		break;
 	}
+
 	return rc;
 }
 
-static int isx005_set_antibanding(int mode)
+/* preview register setting */
+static int isx005_reg_preview(void)
 {
-	int rc;
+	int rc = 0;
+	int i;
+	unsigned short temp;
+
+	/* Configure sensor for Preview mode */
+	// 2010-12-31 for upgrading sensor stability
+	for (i = 0; i < isx005_regs.prev_reg_settings_size; ++i) {
+	 if ( isx005_regs.prev_reg_settings[i].register_address == 0xeeee ) {
+   printk(KERN_ERR "preview delay time %d\n", isx005_regs.prev_reg_settings[i].register_value);
+   mdelay(isx005_regs.prev_reg_settings[i].register_value);
+	 } else if ( isx005_regs.prev_reg_settings[i].register_address == 0xdddd ) {
+	  do {
+ 	  isx005_i2c_write(isx005_client->addr, 0x098E, 0x8400, WORD_LEN);
+ 	  isx005_i2c_read(isx005_client->addr, 0x0990, &temp, WORD_LEN);
+ 	 } while( temp & 0x0001 );
+	 } else if ( isx005_regs.prev_reg_settings[i].register_address == 0xddd1 ) {
+	  do {
+ 	  isx005_i2c_write(isx005_client->addr, 0x098E, 0x8400, WORD_LEN);
+ 	  isx005_i2c_read(isx005_client->addr, 0x0990, &temp, WORD_LEN);
+    printk(KERN_ERR "preview extra polling %d\n", temp);
+ 	 } while( temp & 0x0005 );
+	 } else {
+  	rc = isx005_i2c_write(isx005_client->addr,
+ 	  isx005_regs.prev_reg_settings[i].register_address,
+ 	  isx005_regs.prev_reg_settings[i].register_value,
+ 	  isx005_regs.prev_reg_settings[i].register_length);
+	 }
 
-	switch (mode) {
-	case CAMERA_ANTIBANDING_OFF:
-		rc = isx005_i2c_write(isx005_client->addr, 0x4001, 0x00,
-			BYTE_LEN);
 		if (rc < 0)
 			return rc;
+	}
 
-		break;
+	return rc;
+}
 
-	case CAMERA_ANTIBANDING_60HZ:
-		rc = isx005_i2c_write(isx005_client->addr, 0x4001, 0x04,
-			BYTE_LEN);
-		if (rc < 0)
-			return rc;
+/* capture register setting */
+static int isx005_reg_snapshot(void)
+{
+	int rc = 0;
+	int i;
+	unsigned short temp;
 
-		break;
+	/* Configure sensor for Snapshot mode */
+	for (i = 0; i < isx005_regs.snap_reg_settings_size; ++i) {
+	 if ( isx005_regs.snap_reg_settings[i].register_address == 0xeeee ) {
+   printk(KERN_ERR "capture delay time %d\n", isx005_regs.snap_reg_settings[i].register_value);
+   mdelay(isx005_regs.snap_reg_settings[i].register_value);
+	 } else if ( isx005_regs.snap_reg_settings[i].register_address == 0xdddd ) {
+    do {
+     isx005_i2c_write(isx005_client->addr, 0x098E, 0x8400, WORD_LEN);
+     isx005_i2c_read(isx005_client->addr, 0x0990, &temp, WORD_LEN);
+    } while( temp & 0x0002 );
+	 } else {
+ 		rc = isx005_i2c_write(isx005_client->addr,
+ 			isx005_regs.snap_reg_settings[i].register_address,
+ 			isx005_regs.snap_reg_settings[i].register_value,
+ 			isx005_regs.snap_reg_settings[i].register_length);
+ 	}
 
-	case CAMERA_ANTIBANDING_50HZ:
-		rc = isx005_i2c_write(isx005_client->addr, 0x4001, 0x03,
-			BYTE_LEN);
 		if (rc < 0)
 			return rc;
+	}
 
-		break;
+	return rc;
+}
 
-	case CAMERA_ANTIBANDING_AUTO:
-		rc = isx005_i2c_write(isx005_client->addr, 0x4001, 0x00,
-			BYTE_LEN);
-		if (rc < 0)
-			return rc;
+// 2010-11-24 change the framerate mode between capture and video
+static int isx005_change_sensor_mode(int mode)
+{
+ int rc;
 
-		break;
+ switch (mode) {
+	case FRAME_RATE_AUTO:
+	 printk(KERN_ERR "FRAME_RATE_AUTO\n");
 
-	case CAMERA_MAX_ANTIBANDING:
-		rc = isx005_i2c_write(isx005_client->addr, 0x4001, 0x04,
-			BYTE_LEN);
-		if (rc < 0)
-			return rc;
+	 rc = isx005_i2c_write_table(
+		isx005_regs.auto_framerate_reg_settings,
+		isx005_regs.auto_framerate_reg_settings_size);
+  break;
 
+ case FRAME_RATE_FIXED:
+  printk(KERN_ERR "FRAME_RATE_FIXED\n");
+
+	 rc = isx005_i2c_write_table(
+		isx005_regs.fixed_framerate_reg_settings,
+		isx005_regs.fixed_framerate_reg_settings_size);
 		break;
 
 	default:
 		return -EINVAL;
 	}
 
+ /* init_code */
+ if ( sensor_type == APTINA_SENSOR ) {
+  // 2010-12-31 impove stability when sensor mode changed between capture mode and video mode
+  if ( chgUICmd ) {
+   printk(KERN_ERR "change mode delay 350\n");
+   mdelay(350);
+  }
+ }
+
 	return rc;
 }
 
-static int isx005_set_iso(int iso)
+static int isx005_set_sensor_mode(int mode)
 {
-	int32_t rc;
-
-	switch (iso) {
-	case CAMERA_ISO_AUTO:
-		rc = isx005_i2c_write(isx005_client->addr,
-				0x01E5, 0x00, BYTE_LEN);
-		break;
-
-	case CAMERA_ISO_DEBLUR:	/* Do not support */
-	case CAMERA_ISO_100:
-		rc = isx005_i2c_write(isx005_client->addr,
-				0x01E5, 0x04, BYTE_LEN);
-		break;
-
-	case CAMERA_ISO_200:
-		rc = isx005_i2c_write(isx005_client->addr,
-				0x01E5, 0x07, BYTE_LEN);
-		break;
+	int rc = 0;
+	int retry = 0;
 
-	case CAMERA_ISO_400:
-		rc = isx005_i2c_write(isx005_client->addr,
-				0x01E5, 0x0A, BYTE_LEN);
+	switch (mode) {
+	case SENSOR_PREVIEW_MODE:
+		for (retry = 0; retry < 3; ++retry) {
+   printk(KERN_ERR "preview mode\n");
+   //mdelay(60);  // 1 frame skip ==> total 2 frames skip
+			rc = isx005_reg_preview();
+			if (rc < 0)
+				printk(KERN_ERR "[ERROR]%s:Sensor Preview Mode Fail\n",
+					__func__);
+			else {
+			 //printk(KERN_ERR "preview delay 300\n");
+			 //mdelay(300);  // 2 frames skip
+				break;
+			}
+		}
 		break;
 
-	case CAMERA_ISO_800:
-		rc = isx005_i2c_write(isx005_client->addr,
-				0x01E5, 0x0D, BYTE_LEN);
+	case SENSOR_SNAPSHOT_MODE:
+	case SENSOR_RAW_SNAPSHOT_MODE:	/* Do not support */
+		for (retry = 0; retry < 3; ++retry) {
+   printk(KERN_ERR "snapshot mode\n");
+   //mdelay(100);  // msm memory ready time (very important!!!)
+			rc = isx005_reg_snapshot();
+			if (rc < 0)
+				printk(KERN_ERR "[ERROR]%s:Sensor Snapshot Mode Fail\n",
+					__func__);
+			else
+				break;
+		}
 		break;
 
 	default:
-		rc = -EINVAL;
+		return -EINVAL;
 	}
 
+	CDBG("Sensor Mode : %d, rc = %d\n", mode, rc);
+
 	return rc;
 }
 
-static int32_t isx005_set_scene_mode(int8_t mode)
+/* effect register setting */
+static int isx005_set_effect(int effect)
 {
-	int32_t rc = 0;
+	int rc = 0;
 
-	if (prev_scene_mode == mode)
-		return rc;
+	switch (effect) {
+	case CAMERA_EFFECT_OFF:
+	 printk(KERN_ERR "Effect Off\n");
 
-	switch (mode) {
-	case CAMERA_SCENE_AUTO:
-		rc = isx005_i2c_write_table(
-			isx005_regs.scene_auto_reg_settings,
-			isx005_regs.scene_auto_reg_settings_size);
-		break;
+	 rc = isx005_i2c_write_table(
+		isx005_regs.effect_off_reg_settings,
+		isx005_regs.effect_off_reg_settings_size);
+  break;
 
-	case CAMERA_SCENE_PORTRAIT:
-		rc = isx005_i2c_write_table(
-			isx005_regs.scene_portrait_reg_settings,
-			isx005_regs.scene_portrait_reg_settings_size);
+ case CAMERA_EFFECT_MONO:
+  printk(KERN_ERR "Effect Mono\n");
+
+	 rc = isx005_i2c_write_table(
+		isx005_regs.effect_mono_reg_settings,
+		isx005_regs.effect_mono_reg_settings_size);
 		break;
 
-	case CAMERA_SCENE_LANDSCAPE:
-		rc = isx005_i2c_write_table(
-			isx005_regs.scene_landscape_reg_settings,
-			isx005_regs.scene_landscape_reg_settings_size);
+	case CAMERA_EFFECT_NEGATIVE:
+	 printk(KERN_ERR "Effect Negative\n");
+
+	 rc = isx005_i2c_write_table(
+		isx005_regs.effect_negative_reg_settings,
+		isx005_regs.effect_negative_reg_settings_size);
 		break;
 
-	case CAMERA_SCENE_SPORTS:
-		rc = isx005_i2c_write_table(
-			isx005_regs.scene_sports_reg_settings,
-			isx005_regs.scene_sports_reg_settings_size);
+	case CAMERA_EFFECT_SOLARIZE:
+	 printk(KERN_ERR "Effect Solarize\n");
+
+	 rc = isx005_i2c_write_table(
+		isx005_regs.effect_solarize_reg_settings,
+		isx005_regs.effect_negative_reg_settings_size);
 		break;
 
-	case CAMERA_SCENE_SUNSET:
-		rc = isx005_i2c_write_table(
-			isx005_regs.scene_sunset_reg_settings,
-			isx005_regs.scene_sunset_reg_settings_size);
+ case CAMERA_EFFECT_SEPIA:
+  printk(KERN_ERR "Effect Sepia\n");
+
+	 rc = isx005_i2c_write_table(
+		isx005_regs.effect_sepia_reg_settings,
+		isx005_regs.effect_sepia_reg_settings_size);
 		break;
 
-	case CAMERA_SCENE_NIGHT:
-		rc = isx005_i2c_write_table(
-			isx005_regs.scene_night_reg_settings,
-			isx005_regs.scene_night_reg_settings_size);
+ case CAMERA_EFFECT_AQUA:
+  printk(KERN_ERR "Effect Aqua\n");
+
+	 rc = isx005_i2c_write_table(
+		isx005_regs.effect_aqua_reg_settings,
+		isx005_regs.effect_aqua_reg_settings_size);
 		break;
 
 	default:
-		printk(KERN_ERR "[ERROR]%s:Incorrect scene mode value\n",
-			__func__);
-	}
-
-	prev_scene_mode = mode;
+		return -EINVAL;
+ }
 
 	return rc;
 }
 
-static int32_t isx005_set_brightness(int8_t brightness)
+/* White Balance register setting */
+static int isx005_set_wb(int mode)
 {
-	int32_t rc = 0;
-
-	switch (brightness) {
-	case 0:
-		rc = isx005_i2c_write(isx005_client->addr,
-				0x0060, 0x80, BYTE_LEN);
-		if (rc < 0)
-			return rc;
-
-		rc = isx005_i2c_write(isx005_client->addr,
-				0x0061, 0x50, BYTE_LEN);
-		if (rc < 0)
-			return rc;
+	int rc = 0;
 
+	switch (mode) {
+	case CAMERA_WB_AUTO:
+	 rc = isx005_i2c_write_table(
+		isx005_regs.wb_auto_reg_settings,
+		isx005_regs.wb_auto_reg_settings_size);
 		break;
 
-	case 1:
-		rc = isx005_i2c_write(isx005_client->addr,
-				0x0060, 0x80, BYTE_LEN);
-		if (rc < 0)
-			return rc;
-
-		rc = isx005_i2c_write(isx005_client->addr,
-				0x0061, 0x60, BYTE_LEN);
-		if (rc < 0)
-			return rc;
-
+	case CAMERA_WB_CUSTOM:	/* Do not support */
 		break;
 
-	case 2:
-		rc = isx005_i2c_write(isx005_client->addr,
-				0x0060, 0x80, BYTE_LEN);
-		if (rc < 0)
-			return rc;
+	case CAMERA_WB_INCANDESCENT: {
 
-		rc = isx005_i2c_write(isx005_client->addr,
-				0x0061, 0x70, BYTE_LEN);
-		if (rc < 0)
-			return rc;
+ 	 printk(KERN_ERR "INCANDESCENT!!!\n");
 
-		break;
+ 	 rc = isx005_i2c_write_table(
+ 		isx005_regs.wb_incandescent_reg_settings,
+ 		isx005_regs.wb_incandescent_reg_settings_size);
+ 		break;
+		}
 
-	case 3:
-		rc = isx005_i2c_write(isx005_client->addr,
-				0x0060, 0xCD, BYTE_LEN);
-		if (rc < 0)
-			return rc;
+	case CAMERA_WB_FLUORESCENT: {
 
-		rc = isx005_i2c_write(isx005_client->addr,
-				0x0061, 0x80, BYTE_LEN);
-		if (rc < 0)
-			return rc;
+	 printk(KERN_ERR "FLUORESCENT!!!\n");
 
+	 rc = isx005_i2c_write_table(
+		isx005_regs.wb_fluorescent_reg_settings,
+		isx005_regs.wb_fluorescent_reg_settings_size);
 		break;
+ }
 
-	case 4:
-		rc = isx005_i2c_write(isx005_client->addr,
-				0x0060, 0xEF, BYTE_LEN);
-		if (rc < 0)
-			return rc;
-
-		rc = isx005_i2c_write(isx005_client->addr,
-				0x0061, 0x80, BYTE_LEN);
-		if (rc < 0)
-			return rc;
+	case CAMERA_WB_DAYLIGHT: {
+	 printk(KERN_ERR "SUNNY!!!\n");
 
+	 rc = isx005_i2c_write_table(
+		isx005_regs.wb_daylight_reg_settings,
+		isx005_regs.wb_daylight_reg_settings_size);
 		break;
+	}
 
-	case 5:
-		rc = isx005_i2c_write(isx005_client->addr,
-				0x0060, 0x00, BYTE_LEN);
-		if (rc < 0)
-			return rc;
+	case CAMERA_WB_CLOUDY_DAYLIGHT: {
 
-		rc = isx005_i2c_write(isx005_client->addr,
-				0x0061, 0x80, BYTE_LEN);
-		if (rc < 0)
-			return rc;
+	 printk(KERN_ERR "CLOUDY!!!\n");
 
+	 rc = isx005_i2c_write_table(
+		isx005_regs.wb_cloudy_reg_settings,
+		isx005_regs.wb_cloudy_reg_settings_size);
 		break;
+	}
 
-	case 6:
-		rc = isx005_i2c_write(isx005_client->addr,
-				0x0060, 0x18, BYTE_LEN);
-		if (rc < 0)
-			return rc;
-
-		rc = isx005_i2c_write(isx005_client->addr,
-				0x0061, 0x80, BYTE_LEN);
-		if (rc < 0)
-			return rc;
+	default:
+		return -EINVAL;
+	}
 
-		break;
+	return rc;
+}
 
-	case 7:
-		rc = isx005_i2c_write(isx005_client->addr,
-				0x0060, 0x7F, BYTE_LEN);
-		if (rc < 0)
-			return rc;
+/* ISO register setting */
+static int isx005_set_iso(int iso)
+{
+	int32_t rc;
 
-		rc = isx005_i2c_write(isx005_client->addr,
-				0x0061, 0x8A, BYTE_LEN);
-		if (rc < 0)
-			return rc;
+	switch (iso) {
+	case CAMERA_ISO_AUTO:
+	 printk(KERN_ERR "ISO AUTO\n");
 
+	 rc = isx005_i2c_write_table(
+		isx005_regs.iso_auto_reg_settings,
+		isx005_regs.iso_auto_reg_settings_size);
 		break;
 
-	case 8:
-		rc = isx005_i2c_write(isx005_client->addr,
-				0x0060, 0x7F, BYTE_LEN);
-		if (rc < 0)
-			return rc;
 
-		rc = isx005_i2c_write(isx005_client->addr,
-				0x0061, 0x9C, BYTE_LEN);
-		if (rc < 0)
-			return rc;
+	case CAMERA_ISO_100:
+	 printk(KERN_ERR "ISO 100\n");
 
+	 rc = isx005_i2c_write_table(
+		isx005_regs.iso_100_reg_settings,
+		isx005_regs.iso_100_reg_settings_size);
 		break;
 
-	case 9:
-		rc = isx005_i2c_write(isx005_client->addr,
-				0x0060, 0x7F, BYTE_LEN);
-		if (rc < 0)
-			return rc;
-
-		rc = isx005_i2c_write(isx005_client->addr,
-				0x0061, 0xAA, BYTE_LEN);
-		if (rc < 0)
-			return rc;
+	case CAMERA_ISO_200:
+	 printk(KERN_ERR "ISO 200\n");
 
+	 rc = isx005_i2c_write_table(
+		isx005_regs.iso_200_reg_settings,
+		isx005_regs.iso_200_reg_settings_size);
 		break;
 
-	case 10:
-		rc = isx005_i2c_write(isx005_client->addr,
-				0x0060, 0x7F, BYTE_LEN);
-		if (rc < 0)
-			return rc;
-
-		rc = isx005_i2c_write(isx005_client->addr,
-				0x0061, 0xC8, BYTE_LEN);
-		if (rc < 0)
-			return rc;
+	case CAMERA_ISO_400:
+	 printk(KERN_ERR "ISO 400\n");
 
+	 rc = isx005_i2c_write_table(
+		isx005_regs.iso_400_reg_settings,
+		isx005_regs.iso_400_reg_settings_size);
 		break;
 
 	default:
-		printk(KERN_ERR "[ERROR]%s:incoreect brightness value\n",
-			__func__);
+		rc = -EINVAL;
 	}
 
 	return rc;
 }
 
+/* brightness register setting */
+static int32_t isx005_set_brightness(int8_t brightness)
+{
+ int rc = 0;
+
+ if ( sensor_type == APTINA_SENSOR ) {
+  rc = isx005_i2c_write(isx005_client->addr,
+                        isx005_regs.brightness_reg_settings[0].register_address,
+                        isx005_regs.brightness_reg_settings[0].register_value,
+                        isx005_regs.brightness_reg_settings[0].register_length);
+  rc = isx005_i2c_write(isx005_client->addr,
+                        isx005_regs.brightness_reg_settings[brightness+1].register_address,
+                        isx005_regs.brightness_reg_settings[brightness+1].register_value,
+                        isx005_regs.brightness_reg_settings[brightness+1].register_length);  
+ } else {  // Samsung sensor
+  rc = isx005_i2c_write(isx005_client->addr,
+                        isx005_regs.brightness_reg_settings[0].register_address,
+                        isx005_regs.brightness_reg_settings[0].register_value,
+                        isx005_regs.brightness_reg_settings[0].register_length);
+  rc = isx005_i2c_write(isx005_client->addr,
+                        isx005_regs.brightness_reg_settings[1].register_address,
+                        isx005_regs.brightness_reg_settings[1].register_value,
+                        isx005_regs.brightness_reg_settings[1].register_length);
+  rc = isx005_i2c_write(isx005_client->addr,
+                        isx005_regs.brightness_reg_settings[brightness+2].register_address,
+                        isx005_regs.brightness_reg_settings[brightness+2].register_value,
+                        isx005_regs.brightness_reg_settings[brightness+2].register_length);
+ }
+ 
+ return rc;
+}
+
 static int isx005_init_sensor(const struct msm_camera_sensor_info *data)
 {
+
+/*
+ #if defined(ISX005_TUN)
+  isx005_read_register_from_file();
+ #endif
+*/ 
+
 	int rc;
 	int num = 0;
+	int i;
 	struct task_struct *p;
+	unsigned short temp;
 
 	rc = data->pdata->camera_power_on();
 	if (rc < 0) {
@@ -1327,8 +814,27 @@ static int isx005_init_sensor(const struct msm_camera_sensor_info *data)
 		return rc;
 	}
 
-	/*pll register write*/
+ // 2011-03-21 Samsung camera sensor porting
+ isx005_i2c_read(isx005_client->addr, 0x3B80, &temp, WORD_LEN);
+ printk("[dual] 0x3B80 = %x", temp);
+
+ if ( temp != 0x0009 ) {
+  sensor_type = SAMSUNG_SENSOR;
+  data->pdata->camera_standy_high();
+  isx005_register2_setting();
+ } else {
+  sensor_type = APTINA_SENSOR;
+ }
+
+ // for tuning mode
+ #if defined(ISX005_TUN)
+  isx005_read_register_from_file();
+ #endif
+
+ //pll
+ printk(KERN_ERR "pll\n");
 	rc = isx005_reg_init();
+
 	if (rc < 0) {
 		for (num = 0; num < 5; num++) {
 			msleep(2);
@@ -1348,17 +854,16 @@ static int isx005_init_sensor(const struct msm_camera_sensor_info *data)
 		}
 	}
 
-	mdelay(16);
-
-	while (tuning_thread_run)
-		msleep(10);
-
-	mutex_lock(&isx005_tuning_mutex);
-	p = kthread_run(isx005_reg_tuning, 0, "reg_tuning");
-	mutex_unlock(&isx005_tuning_mutex);
+ /* init_code */
+ if ( sensor_type == APTINA_SENSOR ) {
+  rc = isx005_reg_tuning();  // Aptina
+ } else {
+  rc = isx005_reg_tuning2();  // Samsung
+ }
 
-	if (IS_ERR(p))
-		return PTR_ERR(p);
+ // 2010-12-31 reduce preview init time
+ skipFstUICmd = true;
+ chgUICmd = false;
 
 	return rc;
 }
@@ -1451,54 +956,8 @@ int isx005_sensor_release(void)
 	mdp_load_thunder_lut(1);	/* Normal LUT */
 #endif
 
-	return rc;
-}
-
-static int dequeue_sensor_config(int cfgtype, int mode)
-{
-	int rc;
-
-	switch (cfgtype) {
-	case CFG_SET_MODE:
-		rc = isx005_set_sensor_mode(mode);
-		break;
-
-	case CFG_SET_EFFECT:
-		rc = isx005_set_effect(mode);
-		break;
-
-	case CFG_MOVE_FOCUS:
-		rc = isx005_move_focus(mode);
-		break;
-
-	case CFG_SET_DEFAULT_FOCUS:
-		rc = isx005_set_default_focus();
-		break;
-
-	case CFG_SET_WB:
-		rc = isx005_set_wb(mode);
-		break;
-
-	case CFG_SET_ANTIBANDING:
-		rc = isx005_set_antibanding(mode);
-		break;
-
-	case CFG_SET_ISO:
-		rc = isx005_set_iso(mode);
-		break;
-
-	case CFG_SET_SCENE:
-		rc = isx005_set_scene_mode(mode);
-		break;
-
-	case CFG_SET_BRIGHTNESS:
-		rc = isx005_set_brightness(mode);
-		break;
-
-	default:
-		rc = 0;
-		break;
-	}
+ /* 2010-12-06 fixed run changing framerate mode repeatly */
+	//prev_fps_mode = -1;
 
 	return rc;
 }
@@ -1530,21 +989,38 @@ int isx005_sensor_config(void __user *argp)
 
 	mutex_lock(&isx005_mutex);
 
+	// 2010-12-10 test
+	printk(KERN_INFO "Config sensor info type %d", cfg_data.cfgtype);
+
 	switch (cfg_data.cfgtype) {
-	case CFG_SET_MODE:
+
+ // 2010-11-24 change the framerate mode between capture and video
+ case CFG_SET_FPS : {
+  rc = isx005_change_sensor_mode(cfg_data.mode);
+  break;
+ }
+
+	case CFG_SET_MODE: {
+	 printk(KERN_INFO "Config Sensor Mode\n");
 		rc = isx005_set_sensor_mode(cfg_data.mode);
 		break;
+	}
 
-	case CFG_SET_EFFECT:
+	case CFG_SET_EFFECT: {
+	 printk(KERN_INFO "Config Effect\n");
 		rc = isx005_set_effect(cfg_data.mode);
+
+  // 2010-12-31 reduce preview init time
+  chgUICmd = true;
 		break;
+ }
 
 	case CFG_MOVE_FOCUS:
-		rc = isx005_move_focus(cfg_data.cfg.focus.steps);
+	 rc = 0;
 		break;
 
 	case CFG_SET_DEFAULT_FOCUS:
-		rc = isx005_set_default_focus();
+	 rc = 0;
 		break;
 
 	case CFG_GET_AF_MAX_STEPS:
@@ -1556,40 +1032,57 @@ int isx005_sensor_config(void __user *argp)
 		break;
 
 	case CFG_START_AF_FOCUS:
-		rc = isx005_set_af_start(cfg_data.mode);
+	 rc = 0;
 		break;
 
-	case CFG_CHECK_AF_DONE:
-		rc = isx005_check_focus(&cfg_data.mode);
-		if (copy_to_user((void *)argp,
-				&cfg_data,
-				sizeof(struct sensor_cfg_data)))
-			rc = -EFAULT;
+ case CFG_CHECK_AF_DONE:
+	 rc = 0;
 		break;
 
 	case CFG_CHECK_AF_CANCEL:
-		rc = isx005_cancel_focus(cfg_data.mode);
+	 rc = 0;
 		break;
 
-	case CFG_SET_WB:
-		rc = isx005_set_wb(cfg_data.mode);
+	case CFG_SET_WB: {
+	 // 2010-12-31 reduce preview init time
+  if ( skipFstUICmd ) {
+	   rc = 0;
+	 } else {
+  	 printk(KERN_INFO "Config white balance\n");
+  		rc = isx005_set_wb(cfg_data.mode);
+    // 2010-12-31 reduce preview init time
+    chgUICmd = true;
+  }
 		break;
+ }
 
-	case CFG_SET_ANTIBANDING:
-		rc = isx005_set_antibanding(cfg_data.mode);
+	case CFG_SET_ANTIBANDING: /* not support */
+	 rc = 0;
 		break;
 
-	case CFG_SET_ISO:
+	case CFG_SET_ISO: {
+	 printk(KERN_INFO "Config ISO\n");
 		rc = isx005_set_iso(cfg_data.mode);
-		break;
 
-	case CFG_SET_SCENE:
-		rc = isx005_set_scene_mode(cfg_data.mode);
 		break;
+ }
+	case CFG_SET_SCENE: /* not support */
+	 rc = 0;
+		break;
+
+	case CFG_SET_BRIGHTNESS: {
+  if ( skipFstUICmd ) {
+	   rc = 0;
+	   skipFstUICmd = false;
+	 } else {
+  		printk(KERN_INFO "Config Brightness\n");
+  		rc = isx005_set_brightness(cfg_data.mode);
+    // 2010-12-31 reduce preview init time
+    chgUICmd = true;
+  }
 
-	case CFG_SET_BRIGHTNESS:
-		rc = isx005_set_brightness(cfg_data.mode);
 		break;
+	}
 
 	default:
 		rc = -EINVAL;
@@ -1758,3 +1251,4 @@ static int __init isx005_init(void)
 }
 
 late_initcall(isx005_init);
+
diff --git a/drivers/media/video/msm/isx005.h b/drivers/media/video/msm/isx005.h
index a98419f..21feacd 100644
--- a/drivers/media/video/msm/isx005.h
+++ b/drivers/media/video/msm/isx005.h
@@ -39,55 +39,74 @@ struct isx005_register_address_value_pair {
 struct isx005_reg {
 	const struct isx005_register_address_value_pair *init_reg_settings;
 	uint16_t init_reg_settings_size;
-#if !defined(CONFIG_MACH_MSM7X27_THUNDERG) && \
-	!defined(CONFIG_MACH_MSM7X27_THUNDERA)
-	const struct isx005_register_address_value_pair *init_reg32_settings;
-	uint16_t init_reg32_settings_size;
-#endif
+
 	const struct isx005_register_address_value_pair *tuning_reg_settings;
 	uint16_t tuning_reg_settings_size;
+	
+	/* framerate mode start */
+	const struct isx005_register_address_value_pair *auto_framerate_reg_settings;
+	uint16_t auto_framerate_reg_settings_size;
+	
+	const struct isx005_register_address_value_pair *fixed_framerate_reg_settings;
+	uint16_t fixed_framerate_reg_settings_size;	
+	/* framerate mode end */
 
 	const struct isx005_register_address_value_pair *prev_reg_settings;
 	uint16_t prev_reg_settings_size;
 	const struct isx005_register_address_value_pair *snap_reg_settings;
 	uint16_t snap_reg_settings_size;
 
-	const struct isx005_register_address_value_pair *af_normal_reg_settings;
-	uint16_t af_normal_reg_settings_size;
-	const struct isx005_register_address_value_pair *af_macro_reg_settings;
-	uint16_t af_macro_reg_settings_size;
-	const struct isx005_register_address_value_pair *af_manual_reg_settings;
-	uint16_t af_manual_reg_settings_size;
-
-	const struct isx005_register_address_value_pair *af_start_reg_settings;
-	uint16_t af_start_reg_settings_size;
-
-	const struct isx005_register_address_value_pair
-		*scene_auto_reg_settings;
-	uint16_t scene_auto_reg_settings_size;
-	const struct isx005_register_address_value_pair
-		*scene_portrait_reg_settings;
-	uint16_t scene_portrait_reg_settings_size;
-	const struct isx005_register_address_value_pair
-		*scene_landscape_reg_settings;
-	uint16_t scene_landscape_reg_settings_size;
-	const struct isx005_register_address_value_pair
-		*scene_sports_reg_settings;
-	uint16_t scene_sports_reg_settings_size;
-	const struct isx005_register_address_value_pair
-		*scene_sunset_reg_settings;
-	uint16_t scene_sunset_reg_settings_size;
-	const struct isx005_register_address_value_pair
-		*scene_night_reg_settings;
-	uint16_t scene_night_reg_settings_size;
-};
-
-/* this value is defined in Android native camera */
-enum isx005_focus_mode {
-	FOCUS_NORMAL,
-	FOCUS_MACRO,
-	FOCUS_AUTO,
-	FOCUS_MANUAL,
+ /* effect start */
+ const struct isx005_register_address_value_pair *effect_off_reg_settings;
+ uint16_t effect_off_reg_settings_size;
+
+ const struct isx005_register_address_value_pair *effect_mono_reg_settings;
+ uint16_t effect_mono_reg_settings_size;
+
+ const struct isx005_register_address_value_pair *effect_negative_reg_settings;
+ uint16_t effect_negative_reg_settings_size;
+
+ const struct isx005_register_address_value_pair *effect_solarize_reg_settings;
+ uint16_t effect_solarize_reg_settings_size;
+
+ const struct isx005_register_address_value_pair *effect_sepia_reg_settings;
+ uint16_t effect_sepia_reg_settings_size;
+
+ const struct isx005_register_address_value_pair *effect_aqua_reg_settings;
+ uint16_t effect_aqua_reg_settings_size;
+ 
+ /* white balance start */
+ const struct isx005_register_address_value_pair *wb_auto_reg_settings;
+ uint16_t wb_auto_reg_settings_size;
+
+ const struct isx005_register_address_value_pair *wb_incandescent_reg_settings;
+ uint16_t wb_incandescent_reg_settings_size;
+
+ const struct isx005_register_address_value_pair *wb_fluorescent_reg_settings;
+ uint16_t wb_fluorescent_reg_settings_size;
+
+ const struct isx005_register_address_value_pair *wb_daylight_reg_settings;
+ uint16_t wb_daylight_reg_settings_size;
+
+ const struct isx005_register_address_value_pair *wb_cloudy_reg_settings;
+ uint16_t wb_cloudy_reg_settings_size; 
+ 
+ /* iso start */
+ const struct isx005_register_address_value_pair *iso_auto_reg_settings;
+ uint16_t iso_auto_reg_settings_size;
+ 
+ const struct isx005_register_address_value_pair *iso_100_reg_settings;
+ uint16_t iso_100_reg_settings_size;
+ 
+ const struct isx005_register_address_value_pair *iso_200_reg_settings;
+ uint16_t iso_200_reg_settings_size;
+ 
+ const struct isx005_register_address_value_pair *iso_400_reg_settings;
+ uint16_t iso_400_reg_settings_size;   
+
+ /* brightness start */
+	const struct isx005_register_address_value_pair *brightness_reg_settings;
+	uint16_t brightness_reg_settings_size; 
 };
 
 /* this value is defined in Android native camera */
@@ -104,14 +123,6 @@ enum isx005_wb_type {
 	CAMERA_WB_MAX_PLUS_1
 };
 
-enum isx005_antibanding_type {
-	CAMERA_ANTIBANDING_OFF,
-	CAMERA_ANTIBANDING_60HZ,
-	CAMERA_ANTIBANDING_50HZ,
-	CAMERA_ANTIBANDING_AUTO,
-	CAMERA_MAX_ANTIBANDING,
-};
-
 /* Enum Type for different ISO Mode supported */
 enum isx005_iso_value {
 	CAMERA_ISO_AUTO = 0,
@@ -123,18 +134,22 @@ enum isx005_iso_value {
 	CAMERA_ISO_MAX
 };
 
-/* Enum type for scene mode */
-enum {
-	CAMERA_SCENE_AUTO = 1,
-	CAMERA_SCENE_PORTRAIT,
-	CAMERA_SCENE_LANDSCAPE,
-	CAMERA_SCENE_SPORTS,
-	CAMERA_SCENE_NIGHT,
-	CAMERA_SCENE_SUNSET,
+// 2010-11-24 change the framerate mode between capture and video
+enum isx005_fps_mode {
+ FRAME_RATE_AUTO = 0,
+ FRAME_RATE_FIXED
+};
+
+// 2011-03-21 Samsung camera sensor porting
+enum isx005_sensor_type {
+ APTINA_SENSOR = 0,
+ SAMSUNG_SENSOR
 };
 
 #if defined(CONFIG_MACH_MSM7X27_THUNDERG) || \
-	defined(CONFIG_MACH_MSM7X27_THUNDERC)
+	defined(CONFIG_MACH_MSM7X27_THUNDERC) || \
+	defined(CONFIG_MACH_MSM7X27_PECAN) || \
+	defined(CONFIG_MACH_MSM7X27_HAZEL) /* 20100911 pecan porting : temp same as thunderg by bongkyu.kim */
 /* LGE_CHANGE_S. Change code to apply new LUT for display quality.
  * 2010-08-13. minjong.gong@lge.com */
 extern void mdp_load_thunder_lut(int lut_type);
